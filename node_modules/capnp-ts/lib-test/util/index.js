"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var path = require("path");
var testcheck_1 = require("testcheck");
var util_1 = require("../../lib/util");
var tap_1 = require("./tap");
exports.tap = tap_1.default;
function diffHex(found, wanted) {
    var a = new Uint8Array(found);
    var b = new Uint8Array(wanted);
    for (var i = 0; i < a.byteLength && i < b.byteLength; i++) {
        if (a[i] !== b[i]) {
            return util_1.format("addr:%a,found:%s,wanted:%s", i, util_1.pad(a[i].toString(16), 2), util_1.pad(b[i].toString(16), 2));
        }
    }
    if (a.byteLength > b.byteLength) {
        return util_1.format("addr:%a,found:%s,wanted:EOF", b.byteLength, util_1.pad(a[b.byteLength].toString(16), 2));
    }
    else if (b.byteLength > a.byteLength) {
        return util_1.format("addr:%a,found:EOF,wanted:%s", a.byteLength, util_1.pad(b[a.byteLength].toString(16), 2));
    }
    return "equal";
}
function compareBuffers(parentTest, found, wanted, name) {
    if (name === void 0) { name = "should have the same buffer contents"; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, parentTest.test(name, function (t) {
                    t.equal(found.byteLength, wanted.byteLength, "should have the same byte length (diff=" + diffHex(found, wanted) + ").");
                    // End the comparison prematurely if the buffer lengths differ.
                    if (found.byteLength !== wanted.byteLength) {
                        t.end();
                        return;
                    }
                    var a = new Uint8Array(found);
                    var b = new Uint8Array(wanted);
                    for (var i = 0; i < a.byteLength; i++) {
                        if (a[i] !== b[i]) {
                            t.fail("bytes are not equal (" + diffHex(found, wanted) + ")");
                            // Don't check any of the other bytes or else we might flood with failures.
                            t.end();
                            return;
                        }
                    }
                    t.end();
                })];
        });
    });
}
exports.compareBuffers = compareBuffers;
// LINT: This is benchmark code, not library code. This does not run as part of the test suite.
/* tslint:disable:no-any no-unsafe-any no-console only-arrow-functions no-invalid-this */
function logBench(suite) {
    return suite
        .on("start", function () {
        console.log("\nStarting benchmark: " + this.name);
    })
        .on("cycle", function (ev) {
        console.log(String(ev.target));
    })
        .on("complete", function () {
        var name = this.name;
        var fastest = this.filter("fastest");
        var slowest = this.filter("slowest");
        var ratio = fastest.map("hz") / slowest.map("hz");
        console.log("Fastest " + name + " is " + fastest.map("name") + " (" + ratio.toFixed(3) + "x faster)");
    });
}
exports.logBench = logBench;
/* tslint:enable:no-any no-unsafe-any no-console only-arrow-functions no-invalid-this */
function readFileBuffer(filePath) {
    var b = fs_1.readFileSync(path.join(__dirname, "../../", filePath));
    return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
}
exports.readFileBuffer = readFileBuffer;
function runTestCheck(parentTest, property, options, name) {
    if (name === void 0) { name = "should satisfy property check"; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, parentTest.test(name, function (t) {
                    var out = testcheck_1.check(property, options);
                    t.equal(out.result, true, "property check failed " + JSON.stringify(out));
                    t.end();
                })];
        });
    });
}
exports.runTestCheck = runTestCheck;

//# sourceMappingURL=index.js.map
