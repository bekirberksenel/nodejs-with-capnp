"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var C = require("../../../lib/constants");
var serialization_1 = require("../../../lib/serialization");
var arena_1 = require("../../../lib/serialization/arena");
var message_1 = require("../../../lib/serialization/message");
var serialization_demo_1 = require("../../integration/serialization-demo");
var util_1 = require("../../util");
var SEGMENTED_PACKED = util_1.readFileBuffer("test/data/segmented-packed.bin");
var SEGMENTED_UNPACKED = util_1.readFileBuffer("test/data/segmented.bin");
util_1.tap.test("new Message(ArrayBuffer, false)", function (t) {
    var message = new serialization_1.Message(SEGMENTED_UNPACKED, false);
    util_1.compareBuffers(t, message.toArrayBuffer(), SEGMENTED_UNPACKED, "should read segmented messages");
    t.end();
});
util_1.tap.test("new Message(Buffer, false)", function (t) {
    var message = new serialization_1.Message(new Buffer(SEGMENTED_UNPACKED), false);
    util_1.compareBuffers(t, message.toArrayBuffer(), SEGMENTED_UNPACKED, "should read messages from a Buffer");
    t.end();
});
util_1.tap.test("new Message(ArrayBuffer)", function (t) {
    var message = new serialization_1.Message(SEGMENTED_PACKED);
    util_1.compareBuffers(t, message.toArrayBuffer(), SEGMENTED_UNPACKED, "should read packed messages");
    t.end();
});
util_1.tap.test("new Message(Buffer)", function (t) {
    var message = new serialization_1.Message(new Buffer(SEGMENTED_PACKED));
    util_1.compareBuffers(t, message.toArrayBuffer(), SEGMENTED_UNPACKED, "should read packed messages from a Buffer");
    t.end();
});
util_1.tap.test("getFramedSegments()", function (t) {
    t.throws(function () {
        return message_1.getFramedSegments(new Uint8Array([
            0x00,
            0x00,
            0x00,
            0x00 // need at least 4 more bytes for an empty message
        ]).buffer);
    }, undefined, "should throw when segment counts are missing");
    t.throws(function () {
        return message_1.getFramedSegments(new Uint8Array([
            0x00,
            0x00,
            0x00,
            0x01,
            0x00,
            0x00,
            0x00,
            0x00 // need at least 4 more bytes for the second segment length
        ]).buffer);
    }, undefined, "should throw when there are not enough segment counts");
    t.throws(function () {
        return message_1.getFramedSegments(new Uint8Array([
            0x00,
            0x00,
            0x00,
            0x00,
            0x10,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00 // but only get 2
        ]).buffer);
    }, undefined, "should throw when message is truncated");
    t.end();
});
util_1.tap.test("Message.allocateSegment()", function (t) {
    var length = C.DEFAULT_BUFFER_SIZE;
    var m1 = new serialization_1.Message();
    m1.allocateSegment(length);
    m1.allocateSegment(length);
    t.throws(function () { return m1.getSegment(1); });
    // Single segment arenas always grow by slightly more than what was allocated.
    t.equal(m1.getSegment(0).buffer.byteLength, length * 2 + C.MIN_SINGLE_SEGMENT_GROWTH, "should replace existing segments");
    var m2 = new serialization_1.Message(new arena_1.MultiSegmentArena());
    m2.allocateSegment(length);
    m2.allocateSegment(length);
    t.equal(m2.getSegment(1).buffer.byteLength, length, "should allocate new segments");
    t.end();
});
util_1.tap.test("Message.dump()", function (t) {
    var m1 = new serialization_1.Message(new arena_1.MultiSegmentArena());
    t.equal(m1.dump(), "================\nNo Segments\n================\n", "should print an empty message");
    var m2 = new serialization_1.Message();
    m2.allocateSegment(16).allocate(16);
    t.equal(m2.dump(), "================\nSegment #0\n================\n\n=== buffer[16] ===\n00000000: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    \u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\u00B7\n", "should print messages");
    t.end();
});
util_1.tap.test("Message.getSegment()", function (t) {
    var s = new serialization_1.Message(new arena_1.MultiSegmentArena()).getSegment(0);
    t.equal(s.byteLength, 8, "should preallocate segment 0");
    t.throws(function () { return new serialization_1.Message().getSegment(1); }, undefined, "should throw when getting out of range segments");
    var m = new serialization_1.Message(new arena_1.MultiSegmentArena([new ArrayBuffer(2)])); // this is too small to hold the root pointer
    t.throws(function () { return m.getSegment(0); }, undefined, "should throw when segment 0 is too small");
    t.end();
});
util_1.tap.test("Message.onCreatePointer()", function (t) {
    // This is why you should cache the result of `getList()` calls and use `List.toArray()` liberally...
    var m = new serialization_1.Message();
    var p = m.initRoot(serialization_demo_1.Person);
    t.throws(function () {
        for (var i = 0; i < C.DEFAULT_TRAVERSE_LIMIT + 1; i++)
            p.getPhones();
    }, undefined, "should throw when exceeding the pointer traversal limit");
    t.end();
});
util_1.tap.test("Message.toArrayBuffer()", function (t) {
    t.equals(new serialization_1.Message().toArrayBuffer().byteLength, 16, "should allocate segment 0 before converting");
    t.end();
});
util_1.tap.test("Message.toPackedArrayBuffer()", function (t) {
    var message = new serialization_1.Message(SEGMENTED_UNPACKED, false);
    util_1.compareBuffers(t, message.toPackedArrayBuffer(), SEGMENTED_PACKED, "should pack messages properly");
    t.end();
});
util_1.tap.test("preallocateSegments()", function (t) {
    t.throws(function () {
        var message = new serialization_1.Message(new arena_1.MultiSegmentArena());
        message_1.preallocateSegments(message);
    }, undefined, "should throw when preallocating an empty arena");
    t.end();
});

//# sourceMappingURL=message.spec.js.map
