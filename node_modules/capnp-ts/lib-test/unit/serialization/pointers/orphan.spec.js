"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lib_1 = require("../../../../lib");
var serialization_1 = require("../../../../lib/serialization");
var util_1 = require("../../../util");
/** Just a silly struct that holds a single pointer to... itself? */
var TestStruct = /** @class */ (function (_super) {
    tslib_1.__extends(TestStruct, _super);
    function TestStruct() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TestStruct.prototype.adoptTest = function (value) {
        lib_1.Struct.adopt(value, lib_1.Struct.getPointer(0, this));
    };
    TestStruct.prototype.disownTest = function () {
        return lib_1.Struct.disown(this.getTest());
    };
    TestStruct.prototype.getTest = function () {
        return lib_1.Struct.getPointerAs(0, TestStruct, this);
    };
    TestStruct.prototype.hasTest = function () {
        return !lib_1.Struct.isNull(lib_1.Struct.getPointer(0, this));
    };
    TestStruct.prototype.initTest = function () {
        return lib_1.Struct.initStructAt(0, TestStruct, this);
    };
    TestStruct.prototype.setTest = function (value) {
        lib_1.Struct.copyFrom(value, lib_1.Struct.getPointer(0, this));
    };
    TestStruct.prototype.getFoo = function () {
        return lib_1.Struct.getUint32(0, this);
    };
    TestStruct.prototype.setFoo = function (value) {
        lib_1.Struct.setUint32(0, value, this);
    };
    TestStruct.prototype.disownList = function () {
        return lib_1.Struct.disown(this.getList());
    };
    TestStruct.prototype.getList = function () {
        return lib_1.Struct.getPointerAs(1, serialization_1.Int32List, this);
    };
    TestStruct.prototype.initList = function (length) {
        return lib_1.Struct.initList(1, serialization_1.Int32List, length, this);
    };
    TestStruct._capnp = {
        displayName: "TestStruct",
        id: "f38ff832f33d57da",
        size: new lib_1.ObjectSize(8, 2)
    };
    return TestStruct;
}(lib_1.Struct));
util_1.tap.test("new Orphan()", function (t) {
    var message = new lib_1.Message();
    var root = message.initRoot(TestStruct);
    var structOrphan = new lib_1.Orphan(root);
    if (structOrphan._capnp === undefined) {
        throw new Error("orphan already adopted?");
    }
    t.equal(structOrphan._capnp.size.dataByteLength, TestStruct._capnp.size.dataByteLength, "should copy the data byte length");
    t.equal(structOrphan._capnp.size.pointerLength, TestStruct._capnp.size.pointerLength, "should copy the pointer count");
    t.ok(lib_1.Struct.isNull(root), "should zero out the struct pointer");
    var list = new lib_1.Message().initRoot(TestStruct).initList(2);
    var listOrphan = new lib_1.Orphan(list);
    if (listOrphan._capnp === undefined) {
        throw new Error("orphan already adopted?");
    }
    t.equal(listOrphan._capnp.length, 2, "should copy the list length");
    t.equal(listOrphan._capnp.elementSize, serialization_1.Int32List._capnp.size, "should copy the list element size");
    t.ok(lib_1.Struct.isNull(list), "should zero out the list pointer");
    t.end();
});
util_1.tap.test("Orphan._moveTo()", function (t) {
    var root = new lib_1.Message().initRoot(TestStruct);
    var oldChild = root.initTest();
    var oldList = root.initList(2);
    oldChild.setFoo(100);
    oldList.set(1, 300);
    var structOrphan = root.disownTest();
    var listOrphan = root.disownList();
    var newChild = root.initTest();
    var newList = root.initList(5);
    t.equal(newChild.getFoo(), 0, "should not contain disowned struct data in new struct");
    t.equal(newList.get(1), 0, "should not contain disowned list data in new list");
    newChild.setFoo(200);
    newList.set(1, 400);
    structOrphan._moveTo(newChild);
    listOrphan._moveTo(newList);
    t.equal(newChild.getFoo(), 100, "should overwrite target struct pointer and keep old data");
    t.equal(newList.get(1), 300, "should overwrite target list pointer and keep old data");
    t.equal(newList.getLength(), 2, "should set the correct list length");
    t.throws(function () {
        structOrphan._moveTo(root.initTest());
    }, undefined, "should not allow re-adoption");
    t.throws(function () {
        var o = root.disownTest();
        o._moveTo(new lib_1.Message().initRoot(TestStruct));
    }, undefined, "should not allow moving to a different message");
    t.end();
});
util_1.tap.test("Orphan.dispose()", function (t) {
    var root = new lib_1.Message().initRoot(TestStruct);
    root.initTest().setFoo(100);
    root.initList(1).set(1, 200);
    var structOrphan = root.disownTest();
    var listOrphan = root.disownList();
    t.equal(root.segment.getUint32(32), 100);
    t.equal(root.segment.getInt32(60), 200);
    structOrphan.dispose();
    t.equal(root.segment.getUint32(32), 0);
    listOrphan.dispose();
    t.equal(root.segment.getInt32(60), 0);
    t.end();
});

//# sourceMappingURL=orphan.spec.js.map
