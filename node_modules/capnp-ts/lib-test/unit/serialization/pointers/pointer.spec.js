"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var lib_1 = require("../../../../lib");
var C = require("../../../../lib/constants");
var util_1 = require("../../../util");
util_1.tap.test("new Pointer()", function (t) {
    var m = new lib_1.Message();
    var s = m.getSegment(0);
    var initialTraversalLimit = m._capnp.traversalLimit;
    t.throws(function () {
        /* tslint:disable-next-line */
        new lib_1.Pointer(s, 0, 0);
    }, undefined, "should throw when exceeding the depth limit");
    var p = new lib_1.Pointer(s, 4);
    t.equal(m._capnp.traversalLimit, initialTraversalLimit - 8, "should track pointer allocation in the message");
    t.throws(function () {
        /* tslint:disable-next-line */
        new lib_1.Pointer(s, -1);
    }, undefined, "should throw with a negative offset");
    t.throws(function () {
        /* tslint:disable-next-line */
        new lib_1.Pointer(s, 100);
    }, undefined, "should throw when exceeding segment bounds");
    t.equal(s.byteLength, 8);
    t.ok(new lib_1.Pointer(s, 8), "should allow creating pointers at the end of the segment");
    t.equal(p.segment, s);
    t.equal(p.byteOffset, 4);
    t.equal(p._capnp.depthLimit, C.MAX_DEPTH);
    t.end();
});
util_1.tap.test("Pointer.adopt(), Pointer.disown()", function (t) {
    var m = new lib_1.Message();
    var s = m.getSegment(0);
    var p = new lib_1.Pointer(s, 0);
    // Empty bit list.
    s.setUint32(0, 0x00000001);
    s.setUint32(4, 0x00000001);
    var o = lib_1.Pointer.disown(p);
    t.equal(s.getUint32(0), 0x00000000);
    t.equal(s.getUint32(4), 0x00000000);
    lib_1.Pointer.adopt(o, p);
    t.equal(s.getUint32(0), 0x00000001);
    t.equal(s.getUint32(4), 0x00000001);
    t.end();
});
util_1.tap.test("Pointer.dump()", function (t) {
    var m = new lib_1.Message();
    var s = m.getSegment(0);
    var p = new lib_1.Pointer(s, 0);
    s.setUint32(0, 0x00000001);
    s.setUint32(4, 0x00000002);
    t.equal(lib_1.Pointer.dump(p), "[01 00 00 00 02 00 00 00]");
    t.end();
});
util_1.tap.test("Pointer.toString()", function (t) {
    var m = new lib_1.Message();
    var s = m.getSegment(0);
    var p = new lib_1.Pointer(s, 0);
    s.setUint32(0, 0x00000001);
    s.setUint32(4, 0x00000002);
    t.equal(p.toString(), "Pointer_0@0x00000000,[01 00 00 00 02 00 00 00],limit:0x7fffffff");
    t.end();
});

//# sourceMappingURL=pointer.spec.js.map
