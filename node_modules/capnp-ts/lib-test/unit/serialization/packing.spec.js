"use strict";
/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", { value: true });
var packing_1 = require("../../../lib/serialization/packing");
var util_1 = require("../../util");
var TAG_DATA = [
    {
        tag: 0,
        weight: 0,
        word: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    },
    {
        tag: 49,
        weight: 3,
        word: [0x09, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00]
    },
    {
        tag: 1,
        weight: 1,
        word: [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    },
    {
        tag: 255,
        weight: 8,
        word: [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]
    },
    {
        tag: 128,
        weight: 1,
        word: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff]
    },
    {
        tag: 255,
        weight: 8,
        word: [0x0a, 0x15, 0x01, 0xac, 0x6d, 0x9f, 0x03, 0xf2]
    },
    {
        tag: 63,
        weight: 6,
        word: [0x41, 0x53, 0x53, 0x48, 0x41, 0x54, 0x00, 0x00]
    }
];
// NOTE: for these tests to work `PACK_SPAN_THRESHOLD` must be set to `2`.
var PACKING_DATA = [
    {
        name: "flat",
        packed: util_1.readFileBuffer("test/data/flat-packed.bin"),
        unpacked: util_1.readFileBuffer("test/data/flat.bin")
    },
    {
        name: "span",
        packed: util_1.readFileBuffer("test/data/span-packed.bin"),
        unpacked: util_1.readFileBuffer("test/data/span.bin")
    },
    {
        name: "test",
        packed: util_1.readFileBuffer("test/data/test-packed.bin"),
        unpacked: util_1.readFileBuffer("test/data/test.bin")
    },
    {
        name: "zero",
        packed: util_1.readFileBuffer("test/data/zero-packed.bin"),
        unpacked: util_1.readFileBuffer("test/data/zero.bin")
    }
];
util_1.tap.test("getHammingWeight()", function (t) {
    t.plan(TAG_DATA.length);
    TAG_DATA.forEach(function (d) { return t.equal(packing_1.getHammingWeight(d.tag), d.weight); });
    t.end();
});
util_1.tap.test("getTagByte()", function (t) {
    t.plan(TAG_DATA.length);
    TAG_DATA.forEach(function (d) { return t.equal(packing_1.getTagByte.apply(null, d.word), d.tag); });
    t.end();
});
util_1.tap.test("getUnpackedByteLength()", function (t) {
    PACKING_DATA.forEach(function (_a) {
        var name = _a.name, packed = _a.packed, unpacked = _a.unpacked;
        t.equal(packing_1.getUnpackedByteLength(packed), unpacked.byteLength, name);
    });
    t.end();
});
util_1.tap.test("getZeroByteCount()", function (t) {
    t.plan(TAG_DATA.length);
    TAG_DATA.forEach(function (d) {
        return t.equal(packing_1.getZeroByteCount.apply(null, d.word), 8 - d.weight);
    });
    t.end();
});
util_1.tap.test("pack()", function (t) {
    PACKING_DATA.forEach(function (_a) {
        var name = _a.name, packed = _a.packed, unpacked = _a.unpacked;
        util_1.compareBuffers(t, packing_1.pack(unpacked), packed, name);
    });
    t.throws(function () { return packing_1.pack(new ArrayBuffer(7)); });
    t.end();
});
util_1.tap.test("unpack()", function (t) {
    PACKING_DATA.forEach(function (_a) {
        var name = _a.name, packed = _a.packed, unpacked = _a.unpacked;
        util_1.compareBuffers(t, packing_1.unpack(packed), unpacked, name);
    });
    t.end();
});

//# sourceMappingURL=packing.spec.js.map
