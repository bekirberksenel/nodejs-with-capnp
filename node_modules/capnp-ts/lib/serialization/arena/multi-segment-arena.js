"use strict";
/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = require("debug");
var constants_1 = require("../../constants");
var errors_1 = require("../../errors");
var util_1 = require("../../util");
var arena_allocation_result_1 = require("./arena-allocation-result");
var arena_kind_1 = require("./arena-kind");
var trace = debug_1.default("capnp:arena:multi");
trace("load");
var MultiSegmentArena = /** @class */ (function () {
    function MultiSegmentArena(buffers) {
        if (buffers === void 0) { buffers = []; }
        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;
        this.buffers = buffers;
        trace("new %s", this);
    }
    MultiSegmentArena.prototype.toString = function () {
        return util_1.format("MultiSegmentArena_segments:%d", getNumSegments(this));
    };
    MultiSegmentArena.allocate = allocate;
    MultiSegmentArena.getBuffer = getBuffer;
    MultiSegmentArena.getNumSegments = getNumSegments;
    return MultiSegmentArena;
}());
exports.MultiSegmentArena = MultiSegmentArena;
function allocate(minSize, m) {
    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));
    m.buffers.push(b);
    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);
}
exports.allocate = allocate;
function getBuffer(id, m) {
    if (id < 0 || id >= m.buffers.length) {
        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));
    }
    return m.buffers[id];
}
exports.getBuffer = getBuffer;
function getNumSegments(m) {
    return m.buffers.length;
}
exports.getNumSegments = getNumSegments;

//# sourceMappingURL=multi-segment-arena.js.map
