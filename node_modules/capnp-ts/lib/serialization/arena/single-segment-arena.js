"use strict";
/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = require("debug");
var constants_1 = require("../../constants");
var errors_1 = require("../../errors");
var util_1 = require("../../util");
var arena_allocation_result_1 = require("./arena-allocation-result");
var arena_kind_1 = require("./arena-kind");
var trace = debug_1.default("capnp:arena:single");
trace("load");
var SingleSegmentArena = /** @class */ (function () {
    function SingleSegmentArena(buffer) {
        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }
        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;
        if ((buffer.byteLength & 7) !== 0) {
            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));
        }
        this.buffer = buffer;
        trace("new %s", this);
    }
    SingleSegmentArena.prototype.toString = function () {
        return util_1.format("SingleSegmentArena_len:%x", this.buffer.byteLength);
    };
    SingleSegmentArena.allocate = allocate;
    SingleSegmentArena.getBuffer = getBuffer;
    SingleSegmentArena.getNumSegments = getNumSegments;
    return SingleSegmentArena;
}());
exports.SingleSegmentArena = SingleSegmentArena;
function allocate(minSize, segments, s) {
    trace("Allocating %x bytes for segment 0 in %s.", minSize, s);
    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;
    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {
        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;
    }
    else {
        minSize = util_1.padToWord(minSize);
    }
    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);
    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word
    // at a time.
    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));
    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);
}
exports.allocate = allocate;
function getBuffer(id, s) {
    if (id !== 0)
        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));
    return s.buffer;
}
exports.getBuffer = getBuffer;
function getNumSegments() {
    return 1;
}
exports.getNumSegments = getNumSegments;

//# sourceMappingURL=single-segment-arena.js.map
