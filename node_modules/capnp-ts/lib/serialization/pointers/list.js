"use strict";
/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var debug_1 = require("debug");
var errors_1 = require("../../errors");
var util_1 = require("../../util");
var list_element_size_1 = require("../list-element-size");
var object_size_1 = require("../object-size");
var pointer_1 = require("./pointer");
var trace = debug_1.default("capnp:list");
trace("load");
/**
 * A generic list class. Implements Filterable,
 */
var List = /** @class */ (function (_super) {
    tslib_1.__extends(List, _super);
    function List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    List.toString = function () {
        return this._capnp.displayName;
    };
    List.prototype.all = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            if (!callbackfn(this.get(i), i))
                return false;
        }
        return true;
    };
    List.prototype.any = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            if (callbackfn(this.get(i), i))
                return true;
        }
        return false;
    };
    List.prototype.ap = function (callbackfns) {
        var _this = this;
        var length = this.getLength();
        var res = [];
        var _loop_1 = function (i) {
            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));
        };
        for (var i = 0; i < length; i++) {
            _loop_1(i);
        }
        return res;
    };
    List.prototype.concat = function (other) {
        var length = this.getLength();
        var otherLength = other.getLength();
        var res = new Array(length + otherLength);
        for (var i = 0; i < length; i++)
            res[i] = this.get(i);
        for (var i = 0; i < otherLength; i++)
            res[i + length] = other.get(i);
        return res;
    };
    List.prototype.drop = function (n) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = n; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.dropWhile = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        var drop = true;
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            if (drop)
                drop = callbackfn(v, i);
            if (!drop)
                res.push(v);
        }
        return res;
    };
    List.prototype.empty = function () {
        return [];
    };
    List.prototype.every = function (callbackfn) {
        return this.all(callbackfn);
    };
    List.prototype.filter = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                res.push(value);
        }
        return res;
    };
    List.prototype.find = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                return value;
        }
        return undefined;
    };
    List.prototype.findIndex = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                return i;
        }
        return -1;
    };
    List.prototype.forEach = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++)
            callbackfn(this.get(i), i);
    };
    List.prototype.get = function (_index) {
        return get(_index, this);
    };
    /**
     * Get the length of this list.
     *
     * @returns {number} The number of elements in this list.
     */
    List.prototype.getLength = function () {
        return pointer_1.getTargetListLength(this);
    };
    List.prototype.groupBy = function (callbackfn) {
        var length = this.getLength();
        var res = {};
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            res[callbackfn(v, i)] = v;
        }
        return res;
    };
    List.prototype.intersperse = function (sep) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = 0; i < length; i++) {
            if (i > 0)
                res.push(sep);
            res.push(this.get(i));
        }
        return res;
    };
    List.prototype.map = function (callbackfn) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = 0; i < length; i++)
            res[i] = callbackfn(this.get(i), i);
        return res;
    };
    List.prototype.reduce = function (callbackfn, initialValue) {
        var i = 0;
        var res;
        if (initialValue === undefined) {
            // LINT: It's okay, I know what I'm doing here.
            /* tslint:disable-next-line:no-any */
            res = this.get(0);
            i++;
        }
        else {
            res = initialValue;
        }
        for (; i < this.getLength(); i++)
            res = callbackfn(res, this.get(i), i);
        return res;
    };
    List.prototype.set = function (_index, _value) {
        set(_index, _value, this);
    };
    List.prototype.slice = function (start, end) {
        if (start === void 0) { start = 0; }
        var length = end ? Math.min(this.getLength(), end) : this.getLength();
        var res = new Array(length - start);
        for (var i = start; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.some = function (callbackfn) {
        return this.any(callbackfn);
    };
    List.prototype.take = function (n) {
        var length = Math.min(this.getLength(), n);
        var res = new Array(length);
        for (var i = 0; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.takeWhile = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        var take;
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            take = callbackfn(v, i);
            if (!take)
                return res;
            res.push(v);
        }
        return res;
    };
    List.prototype.toArray = function () {
        return this.map(util_1.identity);
    };
    List.prototype.toString = function () {
        return "List_" + _super.prototype.toString.call(this);
    };
    List._capnp = {
        displayName: "List<Generic>",
        size: list_element_size_1.ListElementSize.VOID
    };
    List.get = get;
    List.initList = initList;
    List.set = set;
    return List;
}(pointer_1.Pointer));
exports.List = List;
/**
 * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in
 * the same segment as this pointer.
 *
 * @param {ListElementSize} elementSize The size of each element in the list.
 * @param {number} length The number of elements in the list.
 * @param {List<T>} l The list to initialize.
 * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for
 * composite lists.
 * @returns {void}
 */
function initList(elementSize, length, l, compositeSize) {
    var c;
    switch (elementSize) {
        case list_element_size_1.ListElementSize.BIT:
            c = l.segment.allocate(Math.ceil(length / 8));
            break;
        case list_element_size_1.ListElementSize.BYTE:
        case list_element_size_1.ListElementSize.BYTE_2:
        case list_element_size_1.ListElementSize.BYTE_4:
        case list_element_size_1.ListElementSize.BYTE_8:
        case list_element_size_1.ListElementSize.POINTER:
            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));
            break;
        case list_element_size_1.ListElementSize.COMPOSITE:
            if (compositeSize === undefined) {
                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));
            }
            compositeSize = object_size_1.padToWord(compositeSize);
            var byteLength = object_size_1.getByteLength(compositeSize) * length;
            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance
            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything
            // starts off zeroed out so these nested structs don't need to be initialized in any way.
            c = l.segment.allocate(byteLength + 8);
            pointer_1.setStructPointer(length, compositeSize, c);
            trace("Wrote composite tag word %s for %s.", c, l);
            break;
        case list_element_size_1.ListElementSize.VOID:
            // No need to allocate anything, we can write the list pointer right here.
            pointer_1.setListPointer(0, elementSize, length, l);
            return;
        default:
            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));
    }
    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);
    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);
}
exports.initList = initList;
function get(_index, _l) {
    throw new TypeError();
}
exports.get = get;
function set(_index, _value, _l) {
    throw new TypeError();
}
exports.set = set;

//# sourceMappingURL=list.js.map
