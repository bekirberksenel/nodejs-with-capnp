"use strict";
/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = require("debug");
var constants_1 = require("../constants");
var errors_1 = require("../errors");
var util_1 = require("../util");
var trace = debug_1.default("capnp:uint64");
trace("load");
/**
 * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster
 * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.
 *
 * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!
 *
 * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.
 *
 * The value passed in as the source buffer is expected to be in little-endian format.
 */
var Uint64 = /** @class */ (function () {
    /**
     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert
     * from other types or use a different offset into the buffer.
     *
     * Will throw if the buffer is not at least 8 bytes long.
     *
     * @constructor
     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.
     */
    function Uint64(buffer) {
        if (buffer.byteLength < 8)
            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);
        this.buffer = buffer;
    }
    Uint64.fromArrayBuffer = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(new Uint8Array(source, offset, 8));
        return new this(new Uint8Array(source.slice(offset, offset + 8)));
    };
    Uint64.fromDataView = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy) {
            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));
        }
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));
    };
    /**
     * Parse a hexadecimal string in **big endian format** as a Uint64 value.
     *
     * @static
     * @param {string} source The source string.
     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.
     */
    Uint64.fromHexString = function (source) {
        if (source.substr(0, 2) === "0x")
            source = source.substr(2);
        if (source.length < 1)
            return Uint64.fromNumber(0);
        if (source[0] === "-")
            throw new RangeError("Source must not be negative.");
        source = util_1.pad(source, 16);
        if (source.length !== 16) {
            throw new RangeError("Source string must contain at most 16 hexadecimal digits.");
        }
        var bytes = source.toLowerCase().replace(/[^\da-f]/g, "");
        var buf = new Uint8Array(new ArrayBuffer(8));
        for (var i = 0; i < 8; i++) {
            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);
        }
        return new Uint64(buf);
    };
    Uint64.fromNumber = function (source) {
        var ret = new this(new Uint8Array(8));
        ret.setValue(source);
        return ret;
    };
    Uint64.fromUint8Array = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(source.subarray(offset, offset + 8));
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));
    };
    Uint64.prototype.equals = function (other) {
        for (var i = 0; i < 8; i++) {
            if (this.buffer[i] !== other.buffer[i])
                return false;
        }
        return true;
    };
    Uint64.prototype.inspect = function () {
        return "[Uint64 " + this.toString(10) + " 0x" + this.toHexString() + "]";
    };
    /**
     * Faster way to check for zero values without converting to a number first.
     *
     * @returns {boolean} `true` if the contained value is zero.
     * @memberOf Uint64
     */
    Uint64.prototype.isZero = function () {
        for (var i = 0; i < 8; i++) {
            if (this.buffer[i] !== 0)
                return false;
        }
        return true;
    };
    Uint64.prototype.setValue = function (loWord, hiWord) {
        var lo = loWord;
        var hi = hiWord;
        if (hi === undefined) {
            hi = lo;
            hi = Math.abs(hi);
            lo = hi % constants_1.VAL32;
            hi = hi / constants_1.VAL32;
            if (hi > constants_1.VAL32)
                throw new RangeError(loWord + " is outside Uint64 range");
            hi = hi >>> 0;
        }
        for (var i = 0; i < 8; i++) {
            this.buffer[i] = lo & 0xff;
            lo = i === 3 ? hi : lo >>> 8;
        }
    };
    /**
     * Convert to a native javascript number.
     *
     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!
     *
     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;
     * otherwise out-of-range values are clamped to +Infinity.
     * @returns {number} A numeric representation of this integer.
     */
    Uint64.prototype.toNumber = function (allowImprecise) {
        var b = this.buffer;
        var x = 0;
        var i = 0;
        var m = 1;
        while (i < 8) {
            var v = b[i];
            x += v * m;
            m *= 256;
            i++;
        }
        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {
            trace("Coercing out of range value %d to Infinity.", x);
            return Infinity;
        }
        return x;
    };
    Uint64.prototype.valueOf = function () {
        return this.toNumber(false);
    };
    Uint64.prototype.toArrayBuffer = function () {
        return this.buffer.buffer;
    };
    Uint64.prototype.toDataView = function () {
        return new DataView(this.buffer.buffer);
    };
    Uint64.prototype.toHexString = function () {
        var hex = "";
        for (var i = 7; i >= 0; i--) {
            var v = this.buffer[i].toString(16);
            if (v.length === 1)
                v = "0" + v;
            hex += v;
        }
        return hex;
    };
    Uint64.prototype.toString = function (radix) {
        return this.toNumber(true).toString(radix);
    };
    Uint64.prototype.toUint8Array = function () {
        return this.buffer;
    };
    return Uint64;
}());
exports.Uint64 = Uint64;

//# sourceMappingURL=uint64.js.map
